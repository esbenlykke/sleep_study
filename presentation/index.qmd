---
title: "Sleep Quality Estimation using Accelerometer Data from Thigh-Mounted Devices During in Free Living Conditions"
subtitle: "(working title)"
author: "Esben Lykke, PhD student"
date: "`r format(Sys.Date(), '%d %B, %Y')`"
format:
  revealjs:
    smaller: true
    theme: moon
    slide-number: true
    preview-links: auto
    logo: images/SDU_WHITE_RGB-png.png
    footer: https://github.com/esbenlykke/sleep_study
    css: my_styles.css
    scrollable: true
embed-resources: true
editor_options: 
  chunk_output_type: console
smooth-scroll: true
bibliography: references.bib
---

## Background {transition="convex"}

```{r}
#| echo: false
library(gt)
library(arrow)
library(visNetwork)
library(tidymodels)
library(tidymodels)
```

- Sleep plays a vital role in health, thus, improving the assessment of sleepâ€“wake outside of a laboratory environment is critical
- The gold standard (PSG) is costly and inconvenient.
- Methods for estimating sleep/wake based on accelerometry exist, primarily from wrist-worn devices
- Cole-Kripke and Sadeh algorithms are commonly used
- determine in-bed time is difficult, usually set by sleep log and/or human scorers
- detect wakefulness is difficult, worse performance in populations with sleep disorders
- typically a two level analysis: epoch based and summarized across night(s)
- Zmachine-derived sleep stats
- 

Purpose... 

## But Esben, what about them sleep stages!? {transition="convex"}

* I did free-living PSG recordings of sleep but...
  - Super fragile -> shitty data
  - Combersome and time consuming
  - free-living when wired up like a robot?
  - would surface skin temperature + acc be enough? Most likely needs HR
  
It was likely a dead end from the get-go :(

## Methods {transition="convex"}

::: {.fragment}

- data preparation, big time-consumer is handling raw acc data
- only thigh data used. HSBC and other is only thigh data...
- all zm recording is considered as in-bed (sensor problem?)
- no sleep stages, only sleep/awake
- sensor problems during sleep, up to 20 consecutive epochs (200 sec) are treated as sleep
- Combine binary classifiers to produce multilabel outcomes (i.e., binary Relevance)
- Evaluated combined classifiers using weighted micro-averaging.
- adjust threshold for in bed awake or give edge in tie breakers??

:::

## Exclusion Criteria {transition="convex" .H2}

```{r}
#| fig-align: center
source(here::here("presentation/code/flowchart_eligible_nights.R"))

flow
```

::: aside
1. @hirshkowitz_national_2015
:::


## Features {transition="convex" .H2}

:::: {.columns}

::: {.fragment .column width="30%"}

**Basic Features**

- Weekday 
- Time of Day
- Placement
- Temperature

:::

::: {.fragment .column width="30%"}

**ACC derived features**^[@skotte_detection_2014]

- Mean ACC X 
- Mean ACC Y
- Mean ACC Z
- Standard Deviation X
- Standard Deviation Y
- Standard Deviation Z
- Max Standard Deviation
- Inclination

:::

::: {.fragment .column width="40%"}

**Sensor-Independent Features**^[@walch_sleep_2019, @forger_simpler_1999]

- Clock Proxy Linear
- Clock Proxy Cosinus

:::

::::

---

## Human Circadian Clock {transition="convex"}

@forger_simpler_1999: a so-called cubic van der Pol equation

::: {.fragment}
$$\frac{dx_c}{dt}=\frac{\pi}{12}\begin{cases}\mu(x_c-\frac{4x^3}{3})-x\begin{bmatrix}(\frac{24}{0.99669\tau_x})^2+kB\end{bmatrix}\end{cases}$$
:::

::: {.fragment .fade-in-then-semi-out}
This thing is dependent on ambient light and body temperature!
:::

::: {.fragment .fade-in-then-semi-out}
@walch_sleep_2019 incorporated this feature using step counts from the Apple Watch
:::

::: {.fragment}
But as demonstrated by @walch_sleep_2019, a simple cosine function does the trick just as well :)
:::

## Circadian Proxy Features {transition="fade"}

```{r}
source(here::here("presentation/code/plot_sensor-independent.R"))

plot_proxy_cos
```

## Circadian Proxy Features {transition="fade"}

```{r}
source(here::here("presentation/code/plot_sensor-independent.R"))

plot_proxy_lin
```

## building Models {transition="convex"}

```{r}
source(here::here("presentation/code/plot_hyperparameter_tuning.R"))

hyper_plot
```

## Estimate Sleep Quality Metrics {transition="fade"}


```{r}
#| fig-asp: .4
source(here::here("presentation/code/plot_pred_example.R"))

plot_ex
```

## Estimate Sleep Quality Metrics {transition="fade"}

```{r}
#| fig-asp: .4
source(here::here("presentation/code/plot_pred_example.R"))

plot_lps
```

::: aside 
This methedology is called binary relevance.
:::

## Estimate Sleep Quality Metrics {transition="fade"}

```{r}
#| fig-asp: .4
source(here::here("presentation/code/plot_pred_example.R"))

plot_tst
```


## Results {transition="convex" .H2}

:::: {.columns}

::: {.fragment .column width="50%"}

### Epoch-Based

* Performance Metrics
  - F1 Score
  - Accuracy
  - Sensitivity
  - Specificity
  - ROC curves
  
:::

::: {.fragment .column width="50%"}

### Summarized across nights {.H3}

* Agreement With Zmachine Sleep Stats 
  - Sleep Period Time
  - Total Sleep Time
  - Sleep Efficiency
  - Latency Until Persistent Sleep
  - Wake After Sleep Onset
  
:::

::::

## ROC Curves {transition="convex"}


```{r}
source(here::here("presentation/code/plot_roc_curves.R"))

roc_plots
```

## ROC Curves {transition="convex"}

```{r}
roc_combined_plots
```

## Lots of Metrics {transition="convex" .H2}

:::: {.columns}

::: {.column}
```{r}
source(here::here("presentation/code/tables_performance.R"))

tab1
```
:::

::: {.column}
```{r}
tab2
```
:::

::::

## Bland-Altman Plots {transition="convex"}

::: {.panel-tabset}

### Decision Tree

```{r}
#| echo: false
source(here::here("presentation/code/plot_ba.R"))

dc_plots[[1]]

dc_plots[[2]]

dc_plots[[3]]

dc_plots[[4]]

dc_plots[[5]]
```

### Logistic Regression

```{r}
lr_plots[[1]]

lr_plots[[2]]

lr_plots[[3]]

lr_plots[[4]]

lr_plots[[5]]
```

### Neural Net

```{r}
nn_plots[[1]]

nn_plots[[2]]

nn_plots[[3]]

nn_plots[[4]]

nn_plots[[5]]
```


### XGBoost

```{r}
xg_plots[[1]]

xg_plots[[2]]

xg_plots[[3]]

xg_plots[[4]]

xg_plots[[5]]
```

:::

## Bland-Altman Analysis {transition="convex" .H2}

```{r}
source(here::here("presentation/code/table_ba.R"))

tab_ba
```


## In-bed classification flow {transition="convex" .H2}

```{r}
in_bed_tree <-
  read_rds(here::here("data/models/fitted_models/in_bed_simple_CART_fit.rds"))

in_bed_tree |>
  extract_fit_engine() |>
  visTree(
    height = "550px",
    nodesPopSize = TRUE,
    minNodeSize = 10,
    maxNodeSize = 30,
    fallenLeaves = TRUE,
    legend = FALSE,
    digits = 3,
    direction = "UD",
    colorVar = c(
      "#CC5500", "#8B0000", "#FFD700",
      "#228B22", "#654321", "#8B0000", "#FFDB58"
    ),
    export = FALSE
  ) |>
  visNodes(font = list(
    color = "#EEE8D5",
    size = 20,
    strokeWidth = 1
  )) |>
  visEdges(font = list(
    color = "#EEE8D5",
    size = 20,
    strokeWidth = 1
  )) |>
  visInteraction(
    dragNodes = FALSE,
    dragView = FALSE,
    zoomView = FALSE
  )
```

---

## Sleep classification flow {transition="convex" .H2}

```{r}
sleep_tree <-
  read_rds(here::here("data/models/fitted_models/sleep_simple_CART_fit.rds"))

sleep_tree |>
  extract_fit_engine() |>
  visTree(
    height = "550px",
    nodesPopSize = TRUE,
    minNodeSize = 10,
    maxNodeSize = 30,
    fallenLeaves = TRUE,
    legend = FALSE,
    digits = 3,
    direction = "UD",
    colorVar = c(
      "#CC5500", "#8B0000", "#FFD700",
      "#228B22", "#654321", "#8B0000", "#FFDB58"
    ),
    export = FALSE
  ) |>
  visNodes(font = list(
    color = "#EEE8D5",
    strokeWidth = 1
  )) |>
  visEdges(font = list(
    color = "#EEE8D5",
    strokeWidth = 1
  )) |>
  visInteraction(
    dragNodes = FALSE,
    dragView = FALSE,
    zoomView = FALSE
  )
```


## Discussion {transition="convex"}

- heteroscedasticity
- Cheung 2018 table 4: actigraphy provides a sufficiently narrow range of possible mean differences (CI 95%) clinical significant thresholds
- could be interesting to build models on thigh and hip ocmbined.
- multiclass vs multilabel classification
- in-bed awake/sleep is highly imbalanced -> maybe train a new classifier accounting for imbalanced data (SMOTE)
- model combined preds instead?

## References {transition="convex"}
